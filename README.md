# Сервис маршрутизации

## Назначение сервиса

Сервис должен служить маршрутизатором сообщений. Информация будет получаться из внешних систем синхронно через адаптеры и
передаваться асинхронно во внешние системы (точки назначения).

## О чём этот README

В этом документе вы можете прочитать про:

* Архитектуру приложения и то, как работать в её рамках

## Используемые принципы

* Использование интерфейсов везде, где это уместно (DIP)
* Все зависимости должны быть направлены в сторону высокоуровневых модулей (DIP)
* Все поля объекта, устанавливаемые только в конструкторе, должны быть помечены, как `final`

## Архитектура

### Используемые паттерны

* Микросервисная архитектура
* Клиент-сервер
* Publish/subsribe
* Слои
* Порты и адаптеры

### Порты и адаптеры

#### Краткое описание архитектуры

Сервис использует архитектуру "Порты и адаптеры" (также известную под названием "Шестигранная"). В данной архитектуре приложение
является "черным ящиком", окруженным внешними системами, c которыми она осуществляет ввод/вывод. Например, ввод может
осуществляться посредством REST, интерфейса командной строки или чтения сообщения из внешней системы. В качестве примеров вывода
можно привести синхронный вызов внешних систем, чтение и запись в БД, асинхронную отправку сообщений другим микросервисам.

По-сути, этa архитектура представляет собой симметричный вариант "Слоёной архитектуры", где есть система и "всё остальное" -
внешний мир, с которыми приложение общается через адаптеры, находящиеся на его границе.

Архитектура построена так, что ввод-вывод всегда можно подменить тестовым окружением. Кроме того, она обеспечивает независимость
системы от фреймворков и технологий, которые могут меняться довольно часто из-за устаревания, изменения требований или политики
компании.

#### Порты

Понятие "порт" является абстракцией. Порты представляют из себя интерфейсы, которые реализуют driving-адаптеры и юзкейсы. Driven-
адаптеры не реализуют интерфейсы, потому что их вызов происходит извне (вернее, они могут реализовывать интерфейсы, продиктованные
конкретным API (MessageListener в случае JMS, к примеру).

#### Адаптеры

Aдаптеры находятся на границе приложения и отвечают за взаимодействие с внешним миром. Взаимодействия может быть инициировано
извне (через "driven" адаптер) или может быть инициирована самим приложением (через "driving" адаптер).

Адаптеры на стороне ввода принимают информацию извне и преобразуют её в формат, понятный системе. Например, это может быть GUI,
CLI, REST API, очередь сообщений. В случае с REST API, например, задача адаптера - преобразовать HTTP-запрос в DTO. В случае
Spring эту роль выполняет cам фреймворк и контроллер (адаптер).

Адаптеры на стороне вывода, как правило, представляют из себя репозитории, специфические для каждого хранилища, но могут
являться просто шлюзами во внешние системы.

Архитектура ассимметрична в том смысле, что при вводе адаптер через порт вызывает use case, в то время как при выводе use case
через порт вызывает адаптер.

#### Юзкейсы

Через порт (интерфейс) адаптеры вызывают юзкейсы, которые олицетворяют законченную бизнес-операцию, имеющую смысл
для пользователя системы (изменение остатков по счетам и т.п.). В их задачу
входит оркестрация всего бизнес-процесса: они, как правило, принимают пользовательский ввод (через "driving" адаптеры),
манипулируют объектами бизнес-слоя для выполнения свой задачи и осуществляют вывод (через "driven" адаптеры).

Например, при рассчёте кредитного рейтинга use case принимает ввод от REST-контроллера в виде clientGuid,
материализует из БД объект ClientCreditHistory, создаёт объект CreditRatingCalculator, вызывает на нём метод calculateClientRating()
который возвращает ClientCreditRating, преобразует его в DTO и возвращает контроллеру. Таким образом, use case - оcновное
сосредоточение логики приложения, которое должно тщательно тестироваться.

Сложный use case может состоять из отдельных подопераций. Например, при оформлении заказа в интернет-магазине, необходимо
создать сам заказ, уменьшить количество единиц товара на складе и создать запрос для службы отгрузки товара. В этом случае
use case вызывает несколько подопераций в соответствующих application services, каждый из которых воплощает один bounded context:
shoppingService.createOrder(), inventoryService.decreaseQuantity(), shippingService.createShippingRecord(). Каждая такая операция
не представляет из себя ценности по-отдельности, ей обязательно нужен координатор в виде юзкейса. Во всём же остальном она подобна
юзкейсу: принимает DTO на вход, манипулирует бизнес-объектами, осуществляет взаимодействие с внешними системами через порты.

В микросервисной архитектуре с использованием оркестрации юзкейс становится отдельным микросервисом, принимающим пользовательский ввод
и вызывающим другие микросервисы (в которые преобразуются наши application services). Подоперации, содержащиеся в них, не имеют
самостоятельной ценности (нет никакого смысла создавать заказ, уменьшать количество единиц на складе и создавать запрос об отгрузке
товара - эти подоперации имеют смысл лишь вместе). Именно поэтому в микросервисной архитектуре с использованием оркестрации сервисы,
как правило, не автономны и требуют координации.

#### Application services

Сервисы олицетворяют отдельный bounded context: ShoppingService, InventoryService, ShippingService. Они предоставляют удобные "швы",
по которым в будущем наш монолит может быть разделён на микросервисы. В этом случае интерфейс каждого сервиса может стать, к примеру,
REST API. Вследствие этого, при наличии в приложении нескольких контекстов, целесообразно организовать дополнительный слой
абстракции в виде сервисов, а не создавать монструозные юзкейсы, оперирующие несколькими контекстами.

### Слои

Архитектура "Порты и адаптеры" не оговаривает перечень слоёв, однако в этом проекте используются следующие из них:

* Сервисный слой (представлен use case-классами). Оркестрирует доменные объекты согласно бизнес-сценарию. Содержит в себе логику
маршрутизации сообщений
* Доменный слой (представлен классами доменных объектов и доменных сервисов). Содержит всю бизнес-логику (если она будет представлена)
* Инфраструктурный слой (представлен контроллерами и репозиториями). C помощью него идёт общение со внешним миром.

### Инверсия зависимостей

Архитектура микросервиса использует инверсию зависимостей (DIP) для того, чтобы обеспечить лёгкую изменяемоcть системы. Согласно ей,
высокоуровневые модули не могут зависеть от низкоуровневых. Как следствие:

* DTO никогда не покидают сервисный cлой, где происходит их преобразование в доменные объекты. Благодаря этому доменная логика не
  зависит от инфраструктурного слоя
* Все интерфейсы, через которые слой N использует объекты в слое N + 1 (ниже него), находятся на одном уровне со слоем N. Как и в
  предыдущем случае, это устраняет зависимость от низкоуровневых модулей, которые могут свободно меняться. Например, интерфейсы,
  через которые юзкейс вызывает адаптеры, должны лежать на одном с ним слое (application).


### Операции c доменными объектами

В проекте используется паттерн Data mapper, согласно которому доменные сущности не умеют сохранять/извелекать себя из внешних
систем. Эта работа делегируется инфраструктурному слою, который преобразует объект в DTO, оптимизированный для передачи по сети.
Очень часто объекты этого слоя представляют из себя классы, реализующие паттерн "Репозиторий".

### Репозитории

Там, где уместно, в проекте используется паттерн "Репозиторий" из Domain Driven Development. Репозитории оперируют "aggregate root" - графом объектов,
операции над которыми должны проиводиться, как с единым целым. Примером может быть `Account` и `AccountOperation` - последним
бессмысленно оперировать, как отдельной сущностью. Репозиторий гарантирует согласованность данных для операций с сущностями. Как
правило, границы транзакций не выходят за пределы репозитория, внутри же него каждая операция осуществляется транзакционно. Репозиторий
либо реализует логику работы с хранилищем данных напрямую, либо посредством использования DAO, доступ к которым осуществляется внутри одной
транзакции.

Если использование aggregate root не оправдано, DAO могут быть использованы напрямую (без прослойки репозиториев).

### Сценарий работы микросервиса

Принцип работы архитектуры "порты и адаптеры" легче понять, рассмотрев один из сценариев работы с системой.

Предположим, в систему приходит сообщение от внешней системы об изменении остатка по счетам. В системе происходят следующие события:

* Контроллер (адаптер) читает получает сообщение от Spring в виде DTO
* Контроллер вызывает соответствующий use case через его интерфейс (порт)
* Use case (application service) преобразует DTO в доменный объект, вызывая cоответствующий метод у DTO
* На доменном объекте вызываются какие-то методы в соответствии с бизнес-логикой
* Use case передаёт доменный объект адаптеру через его интерфейс (порт)
* Репозиторий конвертирует объект в DTO и отправляет его в целевую систему

В случае нашего сервиса чаще всего будет применена упрощенная схема работы, в которой контроллер получает тело запроса
в виде строки, извлекает заголовок и передаёт их юзкейсу, который принимает решение о маршрутизации, передавая сообщение в
неизменном виде адаптеру внешней системы. Либо же нашим DTO будет являться объект, сконструированный в контроллере из сообщения
и заголовка. Кроме того, пока непонятно, будем ли мы использовать доменный слой в принципе, учитывая сугубо техническую
ориентацию сервиса.

## Добавление нового функционала

### Добавление нового адаптера

Предположим, нужно добавить новый endpoint, который будет отдавать пользователю информацию о счетах через REST API. Функционал надо
делать с нуля. Новый endpoint должен принимать сложные фильтры в виде JSON. В данной архитектуре нужно сделать следующее:

* Добавить адаптер на стороне ввода (REST-контроллер). В случае Spring это может быть класс, аннотированный `@Controller`
* Cоздать DTO на стороне ввода в который будет десериализован клиентский JSON с фильтрами
* Cоздать DTO на стороне ввода, в который будет сериализован ответ пользователю
* Создать порт (интерфейс) на стороне ввода. Через него адаптер будет вызывать use case
* Создать сам use case (сервис). Здесь будет происходить основная работа. Он должен реализовывать порт, описанный выше
* Создать доменные объекты User, UserProfile. Предположим, что они будут соответствовать одному DTO на стороне вывода
* Добавить порт (интерфейс) на стороне вывода
* Добавить адаптер на стороне вывода (репозиторий). Он должен реализовывать порт, описанный выше
* Добавить DTO на стороне вывода. Он будет передан библиотеке, работающей с базой (например, Hibernate или JDBI)

Так будут выглядеть вызовы в одном направлении (от пользователя):
```
User -> Adapter -> Port -> Use case -> Port -> Adapter -> Db
                          \       ^
                           \     /
                            v   /
                            User

В нашем сервисе, как уже упоминалось, возможна упрощённая схема, в которой доменные объекты не используюся, а десериализация
и сериализация сообщения не производится. Это не относится к доступу к хранилищам, таких как БД или кэш.
```
### Разворачивание сервиса

Сервис представляет собой автономный JAR-файл и не требует какого-либо особого окружения для запуска - достаточно сконфигурировать его и
запустить командой типа `java -jar rrs.jar.` Для его сборки нужно склонировать
репозиторий, перейти в его корень и выполнить следующую команду:

`mvn clean package`
